#!/usr/bin/env python
#
# Ahmed S. Darwish <darwish.07@gmail.com>, NO rights reserved
# Python-2.6 _AND_ Python3.0+ compatible
#
# Usage: $script < KERNEL-SCHEDULER-STATS.txt
#        $script rt < KERNEL-SCHEDULER-STATS.txt
#        $script .. < KERNEL-SCHEDULER-STATS.txt
#
# Generate a gnuplot script for plotting desired kthread properties
# over runtime. Input is taken from the raw scheduler statistics, which
# are in turn captured from the kernel's COM1 serial port output.
#
# Options:
#       'rt': plot total threads runtime over time
#       'pr': plot thread priorities change over time
#       'rq': plot cumulative threads wait in runqueues
#       None: equivalent to 'rt'
#

import sys, re

if len(sys.argv) == 1:
    sys.argv.append('rt')

plot_title  = ''
gnuplot_script = 'plot.gp'

#
# The kernel passes thread statistics, line-by-line, in below form:
# ^TicksSinceBoot[[:space:]]\
#  (ThreadID:ThreadPriority:OverallRuntime:AvgRuntime:OverallRunqueueWait:\
#   AvgRunqueuWait:NrHighPrioPreempts:NrSliceEndPreempts[[:space:]])+$
# where each line represents the state of the system after 'TicksSinceBoot'
# system ticks, and every value is in the form: '[[:digit:]]+'.
#
# Note that:
# a) A trailing white space exists after each line
# b) Threads ordering is _not_ consistent accross lines. For example, one
#    line may have:
#    <Ticks>  1:... 2:... 3:... 
#    while another may contain:
#    <Ticks>  3:... 1:... 2:... 
#    where the [123] digits represent 'ThreadID' in the regex above.
#
# The above grammar may seem idiotic, but it's done to simplify the
# scheduler statistics code as far as possible. Such code is executed in
# the kernel's hottest path: the ticks handler.
#

class ThreadStats:
    def __init__(self):
        self.priority = -1              # (Undefined-priority flag)
        self.runtime = 0                # Maximize for throughput
        self.runtime_avg = 0
        self.runqueue_wait = 0
        self.runqueue_wait_avg = 0      # Minimize for latency
        self.preempt_high_prio = 0
        self.preempt_slice_end = 0

outfile = open('formatted-com1-output.txt', 'w')
outfile.write('# Values generated by {0}\n'.format(sys.argv[0]))

thread = {}

max_pid = -1
for line in sys.stdin:
    r1 = re.compile(' ')
    line = r1.split(line)
    ticks = line[0]

    r2 = re.compile(':')
    for tok in line[1:]:
        if tok.isspace():               # trailing whitespace
            break
        attr = r2.split(tok)
        pid = int(attr[0])
        thread[pid] = ThreadStats()
        thread[pid].priority = int(attr[1])
        thread[pid].runtime = int(attr[2])
        thread[pid].runqueue_wait = int(attr[4])
        max_pid = max(pid, max_pid)

    outfile.write(ticks + ' ')
    try:
        for i in range(max_pid + 1): {
            'rt': lambda: outfile.write('{0} '.format(thread[i].runtime)),
            'pr': lambda: outfile.write('{0} '.format(thread[i].priority)),
            'rq': lambda: outfile.write('{0} '.format(thread[i].runqueue_wait)),
            } [sys.argv[1]]()
    except KeyError:
        sys.stderr.write(sys.argv[0]+': Unknown option "'+sys.argv[1]+'".\n')
        sys.exit(1)
    outfile.write('\n')

plot_ylabel = {
    'rt': 'Total thread runtime in ticks (HZ = 250)',
    'pr': 'Thread priority (smaller values are less favorable)',
    'rq': 'Cumulative thread wait in runqueues (ticks)'
    }
plot_script = '# Script generated by {0}\n'.format(sys.argv[0])
plot_script += 'set title "{0}"\n'.format(plot_title)
plot_script += 'set xlabel "Kernel runtime in ticks (HZ = 250)"\n'
plot_script += 'set ylabel "{0}"\n'.format(plot_ylabel[sys.argv[1]])
plot_script += 'set key right bottom\n'
plot_script += 'set grid back\n'
plot_script += 'set style data linespoints\n'
plot_script += 'plot "{0}" using 1:2 title "T0"'.format(outfile.name)
for i in range(3, max_pid + 3):
    plot_script += ',\\\n "{0}" using 1:{1} title "T{2}"'.\
        format(outfile.name, i, i - 2)
plot_script += '\n'

script_file = open(gnuplot_script, 'w')
script_file.write(plot_script)

#
# Use these extra commands for GIF output:
# plot_script += 'set terminal gif size 1600,1000;'
# plot_script += 'set xtics 1250;'
# plot_script += 'set output "graph.gif";'
# plot_script += 'replot;'
#
